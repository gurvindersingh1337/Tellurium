package vestige.module.impl.exploit;

import org.lwjgl.opengl.GL11;
import vestige.module.Module;
import vestige.module.Category;
import vestige.setting.impl.BooleanSetting;
import vestige.setting.impl.DoubleSetting;
import vestige.setting.impl.IntegerSetting;

import net.minecraft.block.BlockBed;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.WorldRenderer;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.network.play.client.C07PacketPlayerDigging;
import net.minecraft.network.play.client.C07PacketPlayerDigging.Action;
import net.minecraft.util.AxisAlignedBB;
import net.minecraft.util.BlockPos;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.Vec3;

import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

public class Bednuker extends Module {

    private final BooleanSetting bedESP = new BooleanSetting("BedESP", true);
    private final DoubleSetting range = new DoubleSetting("Range", 5.0, 1.0, 8.0, 0.5);
    private final IntegerSetting delay = new IntegerSetting("Delay", 3, 0, 20, 1);
    private final BooleanSetting breakBlocks = new BooleanSetting("Break Blocks", false);
    private final BooleanSetting breakThrough = new BooleanSetting("Break Through", false);
    private final BooleanSetting onlyWhenOpen = new BooleanSetting("Only When Open", false);

    private final List<BlockPos> beds = new ArrayList<>();
    private int ticks = 0;

    public Bednuker() {
        super("Bednuker", Category.EXPLOIT);
        addSettings(bedESP, range, delay, breakBlocks, breakThrough, onlyWhenOpen);
    }

    public void onEnable() {
        beds.clear();
        ticks = 0;
        super.onEnable();
    }

    public void onDisable() {
        beds.clear();
        super.onDisable();
    }

    public void onUpdate() {
        if (mc == null || mc.theWorld == null || mc.thePlayer == null) return;

        if (ticks > 0) {
            ticks--;
            return;
        }

        double r = range.getValue();
        BlockPos playerPos = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ);

        beds.clear();

        int rInt = (int) Math.ceil(r);

        BlockPos nearest = null;
        double nearestDist = Double.MAX_VALUE;

        for (int x = -rInt; x <= rInt; x++) {
            for (int y = -rInt; y <= rInt; y++) {
                for (int z = -rInt; z <= rInt; z++) {
                    BlockPos pos = playerPos.add(x, y, z);
                    if (!mc.theWorld.isBlockLoaded(pos)) continue;

                    // get state and block safely
                    try {
                        if (mc.theWorld.getBlockState(pos) == null) continue; // defensive, though usually not needed
                    } catch (Exception ignored) {
                        continue;
                    }

                    boolean isBed = mc.theWorld.getBlockState(pos).getBlock() instanceof BlockBed;
                    double dx = (pos.getX() + 0.5) - mc.thePlayer.posX;
                    double dy = (pos.getY() + 0.5) - mc.thePlayer.posY;
                    double dz = (pos.getZ() + 0.5) - mc.thePlayer.posZ;
                    double distSq = dx * dx + dy * dy + dz * dz;

                    if (distSq <= r * r) {
                        if (isBed) {
                            beds.add(pos);
                            if (distSq < nearestDist) {
                                nearestDist = distSq;
                                nearest = pos;
                            }
                        } else if (breakBlocks.isEnabled()) {
                            if (nearest == null || distSq < nearestDist) {
                                nearestDist = distSq;
                                nearest = pos;
                            }
                        }
                    }
                }
            }
        }

        if (nearest != null) {
            if (onlyWhenOpen.isEnabled() && !isAnyBedOpen()) return;
            if (breakThrough.isEnabled() || isDirectlyVisible(nearest)) {
                EnumFacing face = getBestFacing(nearest);
                mc.thePlayer.swingItem();
                try {
                    mc.thePlayer.sendQueue.addToSendQueue(new C07PacketPlayerDigging(Action.START_DESTROY_BLOCK, nearest, face));
                    mc.thePlayer.sendQueue.addToSendQueue(new C07PacketPlayerDigging(Action.STOP_DESTROY_BLOCK, nearest, face));
                } catch (Exception ignored) {}
                try {
                    mc.playerController.onPlayerDamageBlock(nearest, face);
                } catch (Exception ignored) {}
                ticks = delay.getValue();
            }
        }
    }

    public void onRender3D() {
        if (!bedESP.isEnabled()) return;
        if (mc == null || mc.theWorld == null || mc.thePlayer == null) return;

        Color fill = new Color(255, 0, 120, 50);
        Color outline = new Color(255, 0, 120, 220);

        double viewerX = mc.getRenderManager().viewerPosX;
        double viewerY = mc.getRenderManager().viewerPosY;
        double viewerZ = mc.getRenderManager().viewerPosZ;

        for (BlockPos pos : beds) {
            // create AABB in view-relative coordinates
            double x = pos.getX() - viewerX;
            double y = pos.getY() - viewerY;
            double z = pos.getZ() - viewerZ;
            AxisAlignedBB box = new AxisAlignedBB(x, y, z, x + 1.0, y + 1.0, z + 1.0);

            // filled box
            drawFilledBox(box, fill);

            // outline
            GlStateManager.pushMatrix();
            GlStateManager.disableTexture2D();
            GlStateManager.enableBlend();
            GlStateManager.disableDepth();
            GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
            GlStateManager.color(outline.getRed() / 255f, outline.getGreen() / 255f, outline.getBlue() / 255f, outline.getAlpha() / 255f);
            RenderGlobal.drawSelectionBoundingBox(box);
            GlStateManager.enableDepth();
            GlStateManager.disableBlend();
            GlStateManager.enableTexture2D();
            GlStateManager.popMatrix();
        }
    }

    private boolean isDirectlyVisible(BlockPos pos) {
        if (mc == null || mc.theWorld == null || mc.thePlayer == null) return false;
        Vec3 start = mc.thePlayer.getPositionEyes(1.0F);
        Vec3 end = new Vec3(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        try {
            return mc.theWorld.rayTraceBlocks(start, end) == null;
        } catch (Exception ignored) {
            return false;
        }
    }

    private boolean isAnyBedOpen() {
        if (mc == null || mc.theWorld == null || mc.thePlayer == null) return false;
        BlockPos playerPos = new BlockPos(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ);
        for (int x = -3; x <= 3; x++) {
            for (int y = -3; y <= 3; y++) {
                for (int z = -3; z <= 3; z++) {
                    BlockPos check = playerPos.add(x, y, z);
                    if (!mc.theWorld.isBlockLoaded(check)) continue;
                    if (mc.theWorld.getBlockState(check).getBlock() instanceof BlockBed) {
                        for (int bx = -1; bx <= 1; bx++) {
                            for (int by = -1; by <= 1; by++) {
                                for (int bz = -1; bz <= 1; bz++) {
                                    BlockPos air = check.add(bx, by, bz);
                                    if (!mc.theWorld.isBlockLoaded(air)) continue;
                                    if (mc.theWorld.isAirBlock(air)) return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }

    private EnumFacing getBestFacing(BlockPos pos) {
        if (mc == null || mc.thePlayer == null) return EnumFacing.UP;
        EnumFacing best = EnumFacing.UP;
        double bestDot = -Double.MAX_VALUE;
        Vec3 center = new Vec3(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5);
        Vec3 eye = mc.thePlayer.getPositionEyes(1.0F);
        Vec3 dir = center.subtract(eye).normalize();
        for (EnumFacing f : EnumFacing.values()) {
            // construct Vec3 from direction vector components
            Vec3 faceVec = new Vec3(f.getDirectionVec().getX(), f.getDirectionVec().getY(), f.getDirectionVec().getZ());
            double dot = dir.xCoord * faceVec.xCoord + dir.yCoord * faceVec.yCoord + dir.zCoord * faceVec.zCoord;
            if (dot > bestDot) {
                bestDot = dot;
                best = f;
            }
        }
        return best;
    }

    public boolean isBedespEnabled() {
        return bedESP.isEnabled();
    }

    private void drawFilledBox(AxisAlignedBB bb, Color color) {
        GlStateManager.pushMatrix();
        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableDepth();
        GlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);
        float r = color.getRed() / 255f;
        float g = color.getGreen() / 255f;
        float b = color.getBlue() / 255f;
        float a = color.getAlpha() / 255f;
        Tessellator tessellator = Tessellator.getInstance();
        WorldRenderer wr = tessellator.getWorldRenderer();
        wr.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

        // bottom quad
        wr.pos(bb.minX, bb.minY, bb.minZ).color(r, g, b, a).endVertex();
        wr.pos(bb.maxX, bb.minY, bb.minZ).color(r, g, b, a).endVertex();
        wr.pos(bb.maxX, bb.minY, bb.maxZ).color(r, g, b, a).endVertex();
        wr.pos(bb.minX, bb.minY, bb.maxZ).color(r, g, b, a).endVertex();

        // top quad
        wr.pos(bb.minX, bb.maxY, bb.minZ).color(r, g, b, a).endVertex();
        wr.pos(bb.maxX, bb.maxY, bb.minZ).color(r, g, b, a).endVertex();
        wr.pos(bb.maxX, bb.maxY, bb.maxZ).color(r, g, b, a).endVertex();
        wr.pos(bb.minX, bb.maxY, bb.maxZ).color(r, g, b, a).endVertex();

        tessellator.draw();
        GlStateManager.enableDepth();
        GlStateManager.disableBlend();
        GlStateManager.enableTexture2D();
        GlStateManager.popMatrix();
    }
}